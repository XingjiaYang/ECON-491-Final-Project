mode = "regression",
cost = tune()
) %>%
set_engine("kernlab")
recipe_svr_linear = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_linear = workflow() %>%
add_model(model_svr_linear) %>%
add_recipe(recipe_svr_linear)
cv_model_svr_linear = vfold_cv(set_training, v = 10)
grid_svr_linear = tibble(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4)
)
tuned_svr_linear = tune_grid(
workflow_svr_linear,
resamples = cv_model_svr_linear,
grid = grid_svr_linear,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_linear, "objects/model_svr_linear.rds")
saveRDS(recipe_svr_linear, "objects/recipe_svr_linear.rds")
saveRDS(workflow_svr_linear, "objects/workflow_svr_linear.rds")
saveRDS(cv_model_svr_linear, "objects/cv_model_svr_linear.rds")
saveRDS(grid_svr_linear, "objects/grid_svr_linear.rds")
saveRDS(tuned_svr_linear, "objects/tuned_svr_linear.rds")
}
require(kernlab)
# kernel == linear
if (file.exists("objects/tuned_svr_linear.rds")) {
model_svr_linear = readRDS("objects/model_svr_linear.rds")
recipe_svr_linear = readRDS("objects/recipe_svr_linear.rds")
workflow_svr_linear = readRDS("objects/workflow_svr_linear.rds")
cv_model_svr_linear = readRDS("objects/cv_model_svr_linear.rds")
grid_svr_linear = readRDS("objects/grid_svr_linear.rds")
tuned_svr_linear = readRDS("objects/tuned_svr_linear.rds")
} else {
set.seed(123)
model_svr_linear = svm_linear(
mode = "regression",
cost = tune()
) %>%
set_engine("kernlab")
recipe_svr_linear = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_linear = workflow() %>%
add_model(model_svr_linear) %>%
add_recipe(recipe_svr_linear)
cv_model_svr_linear = vfold_cv(set_training, v = 10)
grid_svr_linear = tibble(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4)
)
tuned_svr_linear = tune_grid(
workflow_svr_linear,
resamples = cv_model_svr_linear,
grid = grid_svr_linear,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_linear, "objects/model_svr_linear.rds")
saveRDS(recipe_svr_linear, "objects/recipe_svr_linear.rds")
saveRDS(workflow_svr_linear, "objects/workflow_svr_linear.rds")
saveRDS(cv_model_svr_linear, "objects/cv_model_svr_linear.rds")
saveRDS(grid_svr_linear, "objects/grid_svr_linear.rds")
saveRDS(tuned_svr_linear, "objects/tuned_svr_linear.rds")
}
# Kernel == Polynomial
if (file.exists("objects/tuned_svr_poly.rds")) {
model_svr_poly = readRDS("objects/model_svr_poly.rds")
recipe_svr_poly = readRDS("objects/recipe_svr_poly.rds")
workflow_svr_poly = readRDS("objects/workflow_svr_poly.rds")
cv_model_svr_poly = readRDS("objects/cv_model_svr_poly.rds")
grid_svr_poly = readRDS("objects/grid_svr_poly.rds")
tuned_svr_poly = readRDS("objects/tuned_svr_poly.rds")
} else {
set.seed(123)
model_svr_poly = svm_poly(
mode = "regression",
cost = tune(),
degree = tune()
) %>%
set_engine("kernlab")
recipe_svr_poly = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_poly = workflow() %>%
add_model(model_svr_poly) %>%
add_recipe(recipe_svr_poly)
cv_model_svr_poly = vfold_cv(set_training, v = 10)
grid_svr_poly = crossing(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4),
degree = c(2L, 3L, 4L, 5L)
)
tuned_svr_poly = tune_grid(
workflow_svr_poly,
resamples = cv_model_svr_poly,
grid = grid_svr_poly,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_poly, "objects/model_svr_poly.rds")
saveRDS(recipe_svr_poly, "objects/recipe_svr_poly.rds")
saveRDS(workflow_svr_poly, "objects/workflow_svr_poly.rds")
saveRDS(cv_model_svr_poly, "objects/cv_model_svr_poly.rds")
saveRDS(grid_svr_poly, "objects/grid_svr_poly.rds")
saveRDS(tuned_svr_poly, "objects/tuned_svr_poly.rds")
}
# Kernel == Radial
if (file.exists("objects/tuned_svr_rbf.rds")) {
model_svr_rbf = readRDS("objects/model_svr_rbf.rds")
recipe_svr_rbf = readRDS("objects/recipe_svr_rbf.rds")
workflow_svr_rbf = readRDS("objects/workflow_svr_rbf.rds")
cv_model_svr_rbf = readRDS("objects/cv_model_svr_rbf.rds")
grid_svr_rbf = readRDS("objects/grid_svr_rbf.rds")
tuned_svr_rbf = readRDS("objects/tuned_svr_rbf.rds")
} else {
set.seed(123)
model_svr_rbf = svm_rbf(
mode = "regression",
cost = tune(),
rbf_sigma = tune(),
margin = tune()
) %>%
set_engine("kernlab")
recipe_svr_rbf = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_rbf = workflow() %>%
add_model(model_svr_rbf) %>%
add_recipe(recipe_svr_rbf)
cv_model_svr_rbf = vfold_cv(set_training, v = 10)
grid_svr_rbf = grid_latin_hypercube(
cost(range = c(-4, 4)),
rbf_sigma(range = c(-3, 1)),
margin(range = c(1e-3, 1)),
size = 40
)
tuned_svr_rbf = tune_grid(
workflow_svr_rbf,
resamples = cv_model_svr_rbf,
grid = grid_svr_rbf,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_rbf, "objects/model_svr_rbf.rds")
saveRDS(recipe_svr_rbf, "objects/recipe_svr_rbf.rds")
saveRDS(workflow_svr_rbf, "objects/workflow_svr_rbf.rds")
saveRDS(cv_model_svr_rbf, "objects/cv_model_svr_rbf.rds")
saveRDS(grid_svr_rbf, "objects/grid_svr_rbf.rds")
saveRDS(tuned_svr_rbf, "objects/tuned_svr_rbf.rds")
}
require(kernlab)
# kernel == linear
if (file.exists("objects/tuned_svr_linear.rds")) {
model_svr_linear = readRDS("objects/model_svr_linear.rds")
recipe_svr_linear = readRDS("objects/recipe_svr_linear.rds")
workflow_svr_linear = readRDS("objects/workflow_svr_linear.rds")
cv_model_svr_linear = readRDS("objects/cv_model_svr_linear.rds")
grid_svr_linear = readRDS("objects/grid_svr_linear.rds")
tuned_svr_linear = readRDS("objects/tuned_svr_linear.rds")
} else {
set.seed(123)
model_svr_linear = svm_linear(
mode = "regression",
cost = tune()
) %>%
set_engine("kernlab")
recipe_svr_linear = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_linear = workflow() %>%
add_model(model_svr_linear) %>%
add_recipe(recipe_svr_linear)
cv_model_svr_linear = vfold_cv(set_training, v = 10)
grid_svr_linear = tibble(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4)
)
tuned_svr_linear = tune_grid(
workflow_svr_linear,
resamples = cv_model_svr_linear,
grid = grid_svr_linear,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_linear, "objects/model_svr_linear.rds")
saveRDS(recipe_svr_linear, "objects/recipe_svr_linear.rds")
saveRDS(workflow_svr_linear, "objects/workflow_svr_linear.rds")
saveRDS(cv_model_svr_linear, "objects/cv_model_svr_linear.rds")
saveRDS(grid_svr_linear, "objects/grid_svr_linear.rds")
saveRDS(tuned_svr_linear, "objects/tuned_svr_linear.rds")
}
# Kernel == Polynomial
if (file.exists("objects/tuned_svr_poly.rds")) {
model_svr_poly = readRDS("objects/model_svr_poly.rds")
recipe_svr_poly = readRDS("objects/recipe_svr_poly.rds")
workflow_svr_poly = readRDS("objects/workflow_svr_poly.rds")
cv_model_svr_poly = readRDS("objects/cv_model_svr_poly.rds")
grid_svr_poly = readRDS("objects/grid_svr_poly.rds")
tuned_svr_poly = readRDS("objects/tuned_svr_poly.rds")
} else {
set.seed(123)
model_svr_poly = svm_poly(
mode = "regression",
cost = tune(),
degree = tune()
) %>%
set_engine("kernlab")
recipe_svr_poly = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_poly = workflow() %>%
add_model(model_svr_poly) %>%
add_recipe(recipe_svr_poly)
cv_model_svr_poly = vfold_cv(set_training, v = 10)
grid_svr_poly = crossing(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4),
degree = c(2L, 3L, 4L, 5L)
)
tuned_svr_poly = tune_grid(
workflow_svr_poly,
resamples = cv_model_svr_poly,
grid = grid_svr_poly,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_poly, "objects/model_svr_poly.rds")
saveRDS(recipe_svr_poly, "objects/recipe_svr_poly.rds")
saveRDS(workflow_svr_poly, "objects/workflow_svr_poly.rds")
saveRDS(cv_model_svr_poly, "objects/cv_model_svr_poly.rds")
saveRDS(grid_svr_poly, "objects/grid_svr_poly.rds")
saveRDS(tuned_svr_poly, "objects/tuned_svr_poly.rds")
}
# Kernel == Radial
if (file.exists("objects/tuned_svr_rbf.rds")) {
model_svr_rbf = readRDS("objects/model_svr_rbf.rds")
recipe_svr_rbf = readRDS("objects/recipe_svr_rbf.rds")
workflow_svr_rbf = readRDS("objects/workflow_svr_rbf.rds")
cv_model_svr_rbf = readRDS("objects/cv_model_svr_rbf.rds")
grid_svr_rbf = readRDS("objects/grid_svr_rbf.rds")
tuned_svr_rbf = readRDS("objects/tuned_svr_rbf.rds")
} else {
set.seed(123)
model_svr_rbf = svm_rbf(
mode = "regression",
cost = tune(),
rbf_sigma = tune(),
margin = tune()
) %>%
set_engine("kernlab")
recipe_svr_rbf = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_rbf = workflow() %>%
add_model(model_svr_rbf) %>%
add_recipe(recipe_svr_rbf)
cv_model_svr_rbf = vfold_cv(set_training, v = 10)
grid_svr_rbf = grid_latin_hypercube(
cost(range = c(-4, 4)),
rbf_sigma(range = c(-3, 1)),
margin(range = c(1e-3, 1)),
size = 40
)
tuned_svr_rbf = tune_grid(
workflow_svr_rbf,
resamples = cv_model_svr_rbf,
grid = grid_svr_rbf,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_rbf, "objects/model_svr_rbf.rds")
saveRDS(recipe_svr_rbf, "objects/recipe_svr_rbf.rds")
saveRDS(workflow_svr_rbf, "objects/workflow_svr_rbf.rds")
saveRDS(cv_model_svr_rbf, "objects/cv_model_svr_rbf.rds")
saveRDS(grid_svr_rbf, "objects/grid_svr_rbf.rds")
saveRDS(tuned_svr_rbf, "objects/tuned_svr_rbf.rds")
}
require(kernlab)
# kernel == linear
if (file.exists("objects/tuned_svr_linear.rds")) {
model_svr_linear = readRDS("objects/model_svr_linear.rds")
recipe_svr_linear = readRDS("objects/recipe_svr_linear.rds")
workflow_svr_linear = readRDS("objects/workflow_svr_linear.rds")
cv_model_svr_linear = readRDS("objects/cv_model_svr_linear.rds")
grid_svr_linear = readRDS("objects/grid_svr_linear.rds")
tuned_svr_linear = readRDS("objects/tuned_svr_linear.rds")
} else {
set.seed(123)
model_svr_linear = svm_linear(
mode = "regression",
cost = tune()
) %>%
set_engine("kernlab")
recipe_svr_linear = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_linear = workflow() %>%
add_model(model_svr_linear) %>%
add_recipe(recipe_svr_linear)
cv_model_svr_linear = vfold_cv(set_training, v = 10)
grid_svr_linear = tibble(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4)
)
tuned_svr_linear = tune_grid(
workflow_svr_linear,
resamples = cv_model_svr_linear,
grid = grid_svr_linear,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_linear, "objects/model_svr_linear.rds")
saveRDS(recipe_svr_linear, "objects/recipe_svr_linear.rds")
saveRDS(workflow_svr_linear, "objects/workflow_svr_linear.rds")
saveRDS(cv_model_svr_linear, "objects/cv_model_svr_linear.rds")
saveRDS(grid_svr_linear, "objects/grid_svr_linear.rds")
saveRDS(tuned_svr_linear, "objects/tuned_svr_linear.rds")
}
# Kernel == Polynomial
if (file.exists("objects/tuned_svr_poly.rds")) {
model_svr_poly = readRDS("objects/model_svr_poly.rds")
recipe_svr_poly = readRDS("objects/recipe_svr_poly.rds")
workflow_svr_poly = readRDS("objects/workflow_svr_poly.rds")
cv_model_svr_poly = readRDS("objects/cv_model_svr_poly.rds")
grid_svr_poly = readRDS("objects/grid_svr_poly.rds")
tuned_svr_poly = readRDS("objects/tuned_svr_poly.rds")
} else {
set.seed(123)
model_svr_poly = svm_poly(
mode = "regression",
cost = tune(),
degree = tune()
) %>%
set_engine("kernlab")
recipe_svr_poly = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_poly = workflow() %>%
add_model(model_svr_poly) %>%
add_recipe(recipe_svr_poly)
cv_model_svr_poly = vfold_cv(set_training, v = 10)
grid_svr_poly = crossing(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4),
degree = c(2L, 3L, 4L, 5L)
)
tuned_svr_poly = tune_grid(
workflow_svr_poly,
resamples = cv_model_svr_poly,
grid = grid_svr_poly,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_poly, "objects/model_svr_poly.rds")
saveRDS(recipe_svr_poly, "objects/recipe_svr_poly.rds")
saveRDS(workflow_svr_poly, "objects/workflow_svr_poly.rds")
saveRDS(cv_model_svr_poly, "objects/cv_model_svr_poly.rds")
saveRDS(grid_svr_poly, "objects/grid_svr_poly.rds")
saveRDS(tuned_svr_poly, "objects/tuned_svr_poly.rds")
}
# Kernel == Radial
if (file.exists("objects/tuned_svr_rbf.rds")) {
model_svr_rbf = readRDS("objects/model_svr_rbf.rds")
recipe_svr_rbf = readRDS("objects/recipe_svr_rbf.rds")
workflow_svr_rbf = readRDS("objects/workflow_svr_rbf.rds")
cv_model_svr_rbf = readRDS("objects/cv_model_svr_rbf.rds")
grid_svr_rbf = readRDS("objects/grid_svr_rbf.rds")
tuned_svr_rbf = readRDS("objects/tuned_svr_rbf.rds")
} else {
set.seed(123)
model_svr_rbf = svm_rbf(
mode = "regression",
cost = tune(),
rbf_sigma = tune(),
dials::margin = tune()
?svm_rbf
require(kernlab)
# kernel == linear
if (file.exists("objects/tuned_svr_linear.rds")) {
model_svr_linear = readRDS("objects/model_svr_linear.rds")
recipe_svr_linear = readRDS("objects/recipe_svr_linear.rds")
workflow_svr_linear = readRDS("objects/workflow_svr_linear.rds")
cv_model_svr_linear = readRDS("objects/cv_model_svr_linear.rds")
grid_svr_linear = readRDS("objects/grid_svr_linear.rds")
tuned_svr_linear = readRDS("objects/tuned_svr_linear.rds")
} else {
set.seed(123)
model_svr_linear = svm_linear(
mode = "regression",
cost = tune()
) %>%
set_engine("kernlab")
recipe_svr_linear = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_linear = workflow() %>%
add_model(model_svr_linear) %>%
add_recipe(recipe_svr_linear)
cv_model_svr_linear = vfold_cv(set_training, v = 10)
grid_svr_linear = tibble(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4)
)
tuned_svr_linear = tune_grid(
workflow_svr_linear,
resamples = cv_model_svr_linear,
grid = grid_svr_linear,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_linear, "objects/model_svr_linear.rds")
saveRDS(recipe_svr_linear, "objects/recipe_svr_linear.rds")
saveRDS(workflow_svr_linear, "objects/workflow_svr_linear.rds")
saveRDS(cv_model_svr_linear, "objects/cv_model_svr_linear.rds")
saveRDS(grid_svr_linear, "objects/grid_svr_linear.rds")
saveRDS(tuned_svr_linear, "objects/tuned_svr_linear.rds")
}
# Kernel == Polynomial
if (file.exists("objects/tuned_svr_poly.rds")) {
model_svr_poly = readRDS("objects/model_svr_poly.rds")
recipe_svr_poly = readRDS("objects/recipe_svr_poly.rds")
workflow_svr_poly = readRDS("objects/workflow_svr_poly.rds")
cv_model_svr_poly = readRDS("objects/cv_model_svr_poly.rds")
grid_svr_poly = readRDS("objects/grid_svr_poly.rds")
tuned_svr_poly = readRDS("objects/tuned_svr_poly.rds")
} else {
set.seed(123)
model_svr_poly = svm_poly(
mode = "regression",
cost = tune(),
degree = tune()
) %>%
set_engine("kernlab")
recipe_svr_poly = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_poly = workflow() %>%
add_model(model_svr_poly) %>%
add_recipe(recipe_svr_poly)
cv_model_svr_poly = vfold_cv(set_training, v = 10)
grid_svr_poly = crossing(
cost = c(1e-4, 1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4),
degree = c(2L, 3L, 4L, 5L)
)
tuned_svr_poly = tune_grid(
workflow_svr_poly,
resamples = cv_model_svr_poly,
grid = grid_svr_poly,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_poly, "objects/model_svr_poly.rds")
saveRDS(recipe_svr_poly, "objects/recipe_svr_poly.rds")
saveRDS(workflow_svr_poly, "objects/workflow_svr_poly.rds")
saveRDS(cv_model_svr_poly, "objects/cv_model_svr_poly.rds")
saveRDS(grid_svr_poly, "objects/grid_svr_poly.rds")
saveRDS(tuned_svr_poly, "objects/tuned_svr_poly.rds")
}
# Kernel == Radial
if (file.exists("objects/tuned_svr_rbf.rds")) {
model_svr_rbf = readRDS("objects/model_svr_rbf.rds")
recipe_svr_rbf = readRDS("objects/recipe_svr_rbf.rds")
workflow_svr_rbf = readRDS("objects/workflow_svr_rbf.rds")
cv_model_svr_rbf = readRDS("objects/cv_model_svr_rbf.rds")
grid_svr_rbf = readRDS("objects/grid_svr_rbf.rds")
tuned_svr_rbf = readRDS("objects/tuned_svr_rbf.rds")
} else {
set.seed(123)
model_svr_rbf = svm_rbf(
mode = "regression",
cost = tune(),
rbf_sigma = tune()
) %>%
set_engine("kernlab")
recipe_svr_rbf = recipe(INTRATE ~ ., data = set_training)# %>% step_normalize(all_predictors())
# I do not normalize the data since I will do it later and compared them.
workflow_svr_rbf = workflow() %>%
add_model(model_svr_rbf) %>%
add_recipe(recipe_svr_rbf)
cv_model_svr_rbf = vfold_cv(set_training, v = 10)
grid_svr_rbf = grid_latin_hypercube(
cost(range = c(-4, 4)),
rbf_sigma(range = c(-3, 1)),
size = 40
)
tuned_svr_rbf = tune_grid(
workflow_svr_rbf,
resamples = cv_model_svr_rbf,
grid = grid_svr_rbf,
metrics = metric_set(yardstick::rmse),
control = control_grid(save_pred = TRUE)
)
saveRDS(model_svr_rbf, "objects/model_svr_rbf.rds")
saveRDS(recipe_svr_rbf, "objects/recipe_svr_rbf.rds")
saveRDS(workflow_svr_rbf, "objects/workflow_svr_rbf.rds")
saveRDS(cv_model_svr_rbf, "objects/cv_model_svr_rbf.rds")
saveRDS(grid_svr_rbf, "objects/grid_svr_rbf.rds")
saveRDS(tuned_svr_rbf, "objects/tuned_svr_rbf.rds")
}
select_best(tuned_svr_rbf)
best_params_svr_linear = select_best(tuned_svr_linear, metric = "rmse")
best_params_svr_poly = select_best(tuned_svr_poly, metric = "rmse")
best_params_svr_linear = select_best(tuned_svr_poly, metric = "rmse")
best_params_svr_linear = select_best(tuned_svr_linear, metric = "rmse")
best_params_svr_poly = select_best(tuned_svr_poly, metric = "rmse")
best_params_svr_rbf = select_best(tuned_svr_rbf, metric = "rmse")
workflow_final_svr_linear = finalize_workflow(tuned_svr_linear, best_params_svr_linear)
best_params_svr_linear = select_best(tuned_svr_linear, metric = "rmse")
best_params_svr_poly = select_best(tuned_svr_poly, metric = "rmse")
best_params_svr_rbf = select_best(tuned_svr_rbf, metric = "rmse")
workflow_final_svr_linear = finalize_workflow(workflow_svr_linear, best_params_svr_linear)
workflow_final_svr_poly = finalize_workflow(workflow_svr_poly, best_params_svr_poly)
workflow_final_svr_rbf = finalize_workflow(workflow_svr_rbf, best_params_svr_rbf)
final_fit_svr_linear = fit(workflow_final_svr_linear, data = set_training)
final_fit_svr_poly = fit(workflow_final_svr_poly, data = set_training)
final_fit_svr_rbf = fit(workflow_final_svr_rbf, data = set_training)
pred_svr_linear = predict(final_fit_svr_linear, new_data = set_test)$.pred
pred_svr_poly = predict(final_fit_svr_poly, new_data = set_test)$.pred
pred_svr_rbf = predict(final_fit_svr_rbf, new_data = set_test)$.pred
# RMSE of kernel == linear
rmse(actual = set_test %>% pull(INTRATE), pred_svr_linear)
# RMSE of kernel == polynomial
rmse(actual = set_test %>% pull(INTRATE), pred_svr_poly)
# RMSE of kernel == radian
rmse(actual = set_test %>% pull(INTRATE), pred_svr_rbf)
